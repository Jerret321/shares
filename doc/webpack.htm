<!--
    Powered By nodePPT - This is probably the best web presentation tool so far!
    version: 1.3.1
    site: https://github.com/ksky521/nodePPT
-->
<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>使用webpack前端工作流搭建 - By 江涛</title>
    <link rel="stylesheet" media="all" href="./css/nodeppt.css">
    <link rel="stylesheet" media="only screen and (max-device-width: 480px)" href="./css/phone.css">
    
    <link rel="stylesheet" href="./js/highlight/styles/monokai_sublime.css">
    <link rel="stylesheet" href="./css/font-awesome.css">
    
<link rel="stylesheet" href="./css/theme.moon.css">
</head>
<body>
<div class="slides">
    <slides id="container">
        <slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>使用webpack前端工作流搭建</h1>
<h2>分享人：江涛</h2>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>什么是webpack</h1>
<ul>
<li>静态资源打包工具</li>
<li>兼容多种JS书写规范，具有更强大的JS模块化功能</li>
<li>具有Grunt、Gulp对于静态资源自动化构建的能力<blockquote>
<p>Webpack是一个出色的前端自动化构建工具、模块化工具、资源管理工具</p>
</blockquote>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>为什么要用webpack ?</h1>
<ul class="moveIn">
<li>js模块规范复杂化 - AMD、CommonJS、ES6</li>
<li>项目中资源多样性和依赖性 - js、css、png、svg、sass、less、jade等</li>
<li>开发与线上文件一致性</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>webpack的特性 ?</h1>
<ul class="moveIn">
<li>用于处理文件依赖分析和进行打包，让程序员可以专注组件开发</li>
<li>兼容各种JS模块规范 - AMD、CommonJS、ES6</li>
<li>对各种资源都可支持打包 css、js/jsx、img、svg、fonts等</li>
<li>仅需要对应的加载器即可支持，配置简单，关注文件依赖关系即可</li>
<li>可打包成多个模块，实现公共模块、独立模块按需加载</li>
<li>支持内存打包和实时打包生成文件，性能更快</li>
</ul>

</article></section></slide>
<slide class="slide fill" style="background-image:url('/img/webpack.jpg'); background-size: contain;"><section class="slide-wrapper"></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>安装</h2>
<ul>
<li><p>可以同时安装global和local版本</p>
<pre><code class="javascript">npm install -g webpack
</code></pre>
<pre><code class="javascript">npm install --save-dev webpack
</code></pre>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>webpack 使用和配置</h2>
<ul>
<li>node.js API使用：<pre><code class="javascript">var webpack = require(&#39;webpack&#39;);
</code></pre>
</li>
<li>默认使用当前目录的webpack.config.js作为配置文件。可以根据不同的需求配置不同的config</li>
</ul>
<h2>webpack 基本命令</h2>
<ul>
<li><code>webpack</code>    // 最基本的启动webpack方法</li>
<li><code>webpack -w</code> // 提供watch方法，实时进行打包更新</li>
<li><code>webpack -p</code> // 对打包后的文件进行压缩</li>
<li><code>webpack -d</code> // 提供source map，方便调试。</li>
<li><code>webpack --colors</code> // 输出结果带彩色，比如：会用红色显示耗时较长的步骤</li>
<li><code>webpack --profile</code> // 输出性能数据，可以看到每一步的耗时</li>
<li><code>webpack --display-modules</code> // 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>Demo</h2>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>最简单的Webpack配置文件webpack.config.js如下所示：</h2>
<pre><code class="javascript">module.exports = {
  entry:[
    &#39;./app/main.js&#39;
  ],
  output: {
    path: __dirname + &#39;/dist/&#39;,
    publicPath: &quot;/dist/&quot;,
    filename: &#39;bundle.js&#39;
  }
};
</code></pre>
<ul>
<li>其中entry参数定义了打包后的入口文件，数组中的所有文件会打包生成一个filename文件</li>
<li>output参数定义了输出文件的位置</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>复杂的配置---公共文件提取</h2>
<ul>
<li>将多个页面的公用模块独立打包，从而可以利用浏览器缓存机制来提高页面加载效率</li>
<li>减少页面初次加载时间，只有当某功能被用到时，才去动态的加载</li>
</ul>
<pre><code class="javascript">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);
module.exports = {
  entry: { a: &quot;./a&quot;, b: &quot;./b&quot; },
  output: { filename: &quot;[name].js&quot; },
  plugins: [ new CommonsChunkPlugin(&quot;common.js&quot;) ]
}
</code></pre>
<pre><code class="javascript">&lt;script src=&quot;common.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>复杂的配置</h2>
<ul>
<li>可以选择对应的文件生成公用模块，不同页面加载不同模块</li>
</ul>
<pre><code class="javascript">module.exports = {
    entry: {
        p1: &quot;./page1&quot;,
        p2: &quot;./page2&quot;,
        p3: &quot;./page3&quot;,
        ap1: &quot;./admin/page1&quot;,
        ap2: &quot;./admin/page2&quot;
    },
    output: {
        filename: &quot;[name].js&quot;
    },
    plugins: [
        new CommonsChunkPlugin(&quot;admin-commons.js&quot;, [&quot;ap1&quot;, &quot;ap2&quot;]),
        new CommonsChunkPlugin(&quot;commons.js&quot;, [&quot;p1&quot;, &quot;p2&quot;, &quot;admin-commons.js&quot;])
    ]
};
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>有用的配置项</h2>
<ul>
<li><p><code>module.noParse</code>如果你确定一个模块中没有其它新的依赖, 就可以配置这项，webpack 将不再扫描这个文件中的依赖。</p>
<pre><code class="javascript">module: {
      loaders：[{ test: /\.css$/, loader: &#39;style-loader&#39;}],
      noParse: [/moment-with-locales/]
  }
</code></pre>
</li>
<li><p><code>resolve.alias</code> 是 Webpack 的一个配置项，它的作用是把用户的一个请求重定向到另一个路径</p>
<pre><code class="javascript">resolve: {
      extensions: [&#39;.js&#39;, &#39;.less&#39;, &#39;.css&#39;],
      alias: {
          moment: &quot;moment/min/moment-with-locales.min.js&quot;
      }
  }
</code></pre>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>不同规范的模块加载实现（AMD、CommonJS、ES6）</h2>
<ul>
<li>CommonJS的require函数则是同步加载---使用require.ensure实现兼容</li>
<li>AMD是模块异步加载并保证执行顺序---使用require实现兼容</li>
<li>ES6中使用import实现模块的引入---使用Babel实现兼容</li>
</ul>
<p>在Webpack中推荐CommonJS方式去加载模块，这种方式语法更加简洁直观。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>webpack内部实现命令不同</h2>
<ul>
<li>require.ensure (CommonJs)<pre><code class="javascript">require.ensure([&quot;module-a&quot;, &quot;module-b&quot;], function(require) {
 var a = require(&quot;module-a&quot;);
 // ...
});
</code></pre>
</li>
<li>require (AMD)<pre><code class="javascript">require([&quot;module-a&quot;, &quot;module-b&quot;], function(a, b) {
 // ...
});
</code></pre>
</li>
<li>require.include (request)<pre><code class="javascript">require.ensure([], function(require) {
 require.include(&quot;./file&quot;);
 require(&quot;./file2&quot;);
});
</code></pre>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>code-splitting</h1>
<ul>
<li>对于一个大的web应用把所有代码放到一个文件中是很低效的。特别是如果有些代码块只是在特定环境下需要。</li>
<li>webpack可以通过智能分析，将代码库分解成不同的chunks，可以提取公共部分，可以根据‘需求’拆分chunk，实现按需加载chunk。</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>模块加载器</h2>
<ul>
<li>模块：静态的文件，比如：JavaScript，CSS，LESS，TypeScript，JSX，CoffeeScript，图片等等</li>
<li>文件配置： 通过正则表达式对文件名进行匹配</li>
<li>对于不同的模块有其对应的模块加载器，它们可以进行串联</li>
</ul>
<pre><code class="javascript">module: {
    loaders: [{
        test: /\.less/,
        loader:  &#39;style-loader!css-loader!less-loader&#39;
    }, {
      test: /\.(png|jpe?g)$/,
      loader: &#39;url-loader?limit=10000&amp;name=build/[name].[ext]&#39;
    }]
}
</code></pre>
<ul>
<li>require()还支持在资源path前面指定loader，即require(![loaders list]![source path])形式<pre><code class="javascript">require(“style!css!less!./mystyles.less”);
</code></pre>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>模块的引用</h2>
<ul>
<li>使用require方式直接引用静态文件</li>
<li><p>CSS 被转化为 style 标签</p>
<pre><code class="javascript">require(&#39;./myapp.less&#39;);
 var myapp = require(&#39;./myapp.js&#39;);

 console.log(myapp);
</code></pre>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>图片的打包</h2>
<ul>
<li>使用require方式直接引用静态文件</li>
<li>url-loader可以帮助我们实现图片的封装打包，也可以通过require实现。</li>
<li>图片可能被转化成 base64 格式的 dataUrl</li>
</ul>
<pre><code class="javascript">div.img{
    background: url(../image/xxx.jpg)
}

//或者
var img = document.createElement(&quot;img&quot;);
img.src = require(&quot;../image/xxx.jpg&quot;);
document.body.appendChild(img);
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>css文件独立打包</h2>
<p>通常我们不想把样式打在脚本中，最好独立生成css文件，在页面中外链才好，这时可以使用插件extract-text-webpack-plugin</p>
<pre><code class="javascript">npm install extract-text-webpack-plugin –save-dev
</code></pre>
<pre><code class="javascript">plugins: [
    new ExtractTextPlugin(&#39;styles.css&#39;)
]
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>Webpack-dev-server 开发服务器</h2>
<ul>
<li>基于Node.js Express框架的轻量开发服务器</li>
<li>静态资源Web服务器</li>
<li>开发中会监听文件的变化实时打包</li>
</ul>
<p>对于简单静态页面或者仅依赖于独立服务的前端页面，都可以直接使用这个开发服务器进行开发。</p>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<ul>
<li>Webpack开发服务器需要单独安装，同样是通过npm进行：<pre><code class="javascript">npm install -g webpack-dev-server
</code></pre>
</li>
<li>启动命令如下：<pre><code class="javascript">webpack-dev-server --content-base build/ --hot
</code></pre>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>双服务器模式</h2>
<ul>
<li>配置文件做如下修改<pre><code class="javascript">entry: [
  &#39;./src/page/main.js&#39;,
  &#39;webpack/hot/dev-server&#39;,
  &#39;webpack-dev-server/client?http://10.16.15.199:8080&#39;
]
</code></pre>
<pre><code class="javascript">output: {
  path: __dirname,
  filename: &#39;[name].js&#39;,
  publicPath: &quot;http://10.16.15.199:8080/assets/&quot;
}
</code></pre>
<pre><code class="javascript">plugins: [
  new webpack.HotModuleReplacementPlugin()
]
</code></pre>
</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>webpack-dev-middleware</h2>
<ul>
<li>它是webpack的一个中间件</li>
<li>只能在开发环境中使用</li>
<li>可以实现在内存中实时打包生成虚拟文件，在页面中使用</li>
<li>它有两种模式：watch mode (default)和lazy mode</li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<pre><code class="javascript">var webpackDevMiddleware = require(&quot;webpack-dev-middleware&quot;);
var webpack = require(&quot;webpack&quot;);

var compiler = webpack({
    // configuration
    output: { path: &#39;/&#39; }
});

app.use(webpackDevMiddleware(compiler, {
    // options
}));
</code></pre>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article>
<h2>参考资料</h2>
<ul>
<li><a href="http://webpack.github.io/">webpack 官网</a></li>
<li><a href="http://segmentfault.com/a/1190000002551952">Webpack 入门指迷</a></li>
<li><a href="https://github.com/petehunt/webpack-howto"> Webpack how to</a></li>
<li><a href="http://segmentfault.com/a/1190000003499526">基于webpack搭建前端工程解决方案探索</a></li>
<li><a href="http://www.jianshu.com/p/8adf4c2bfa51">Webpack-dev-server结合后端服务器的热替换配置</a></li>
<li><a href="https://fakefish.github.io/react-webpack-cookbook/">Webpack 和 React 小书</a></li>
<li><a href="http://www.w3ctech.com/topic/1513">2015: 前端工具现状</a></li>
</ul>

</article></section></slide>
<slide class="slide"><section class="slide-wrapper"><article class="flexbox vcenter">
<h1>联系方式</h1>
<ul>
<li><strong>Email:</strong> <a href="mailto:321jiangtao@gmail.com">321jiangtao@gmail.com</a></li>
<li><strong>Github:</strong> <a href="https://github.com/jtHwong">https://github.com/jtHwong</a></li>
</ul>

</article></section></slide>
        

        <slide class="slide logoslide dark nobackground">
            <article class="flexbox vcenter">
              <h2 style="color: white;">Powered By nodePPT v1.3.1</h2>
            </article>
          </slide>
        <div class="slideTip" id="tip"></div>
    </slides>
</div>
<canvas id="drawBoard" class="draw-board" width="900" height="700"></canvas>
<div class="progress"><span id="progress"></span></div>
<div id="_buttons">
    <div class="_btn-box" id="_btn-box" style="display:none;">
        <button class="fa fa-arrow-circle-left" id="_btn-prev"></button>
        <button class="fa fa-arrow-circle-right" id="_btn-next"></button>
        <button class="fa fa-paint-brush" id="_btn-brush"></button>
        <button class="fa fa-compress" id="_btn-overview" data-toggle="fa fa-expand"></button>
    </div>
    <button class="fa fa-bars" id="_btn-bar"  data-toggle="fa fa-close"></button>
</div>
<script src="./js/mixjs/lib/mix.0.3.0.min.js"></script>
<script>
var base = location.protocol + '//' + location.host;

var path = location.pathname.split('/').filter(function(v){
    return !!v;
});
path.pop();
path = path.join('/');
MixJS.config({
    baseURL: [ base, path, 'js'].join('/')+'/'
});

</script>
<script src="./js/mixjs/lib/event/broadcast.js"></script>
<script src="./js/nodeppt.js"></script>
<script>
Slide.init({
    containerID: 'container',
    drawBoardID: 'drawBoard',
    slideClass: '.slide',
    buildClass: '.build',
    progressID: 'progress',
    transition: 'card',
    width: 1100,
    dir: './',
    
    //打开下面的注释就开启postMessage方式
    //访问网址127.0.0.1:8080/ppt/demo#client
    control:{
        type: 'postMessage',
        args:{
            isControl:  false
        }
    },
    
    tipID: 'tip'
});
MixJS.loadJS('highlight/hljs-0.8.js',function(){
    hljs.tabReplace = '  ';
    hljs.initHighlightingOnLoad();
});
</script>
<link rel="stylesheet" href="./css/demo.css">
/img

<!--placeholder-->
</body>
</html>
